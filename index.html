<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Testes de Segurança AVANÇADOS do Console - Por Desenvolvedor</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f0f0f0;
            color: #333;
        }
        .container {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            color: #cc0000; /* Vermelho para indicar testes mais sérios */
        }
        button {
            padding: 10px 15px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            background-color: #dc3545; /* Vermelho mais escuro para botões de risco */
            color: white;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background-color: #c82333;
        }
        input[type="text"] {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: calc(70% - 10px);
            box-sizing: border-box;
        }
        textarea {
            width: 98%;
            height: 100px;
            margin-top: 10px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        pre {
            background-color: #e2e2e2;
            padding: 10px;
            border-radius: 5px;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 200px;
            overflow-y: auto;
        }
        .result {
            margin-top: 10px;
            padding: 15px;
            border: 1px solid #ccc;
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        .error-message {
            color: red;
            font-weight: bold;
        }
        .success-message {
            color: green;
            font-weight: bold;
        }
        canvas {
            display: block;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>⚠️ Testes de Segurança AVANÇADOS do Navegador do Console ⚠️</h1>
        <p>Estes testes são mais agressivos e podem potencialmente causar instabilidade no navegador ou no console. **Prossiga com cautela.**</p>

        ---

        <h2>1. Teste de Fragmentação de Memória e Objetos Pesados</h2>
        <p>Cria e descarta muitos objetos complexos. Pode levar a lentidão ou travamentos se o coletor de lixo não for eficiente.</p>
        <button onclick="startMemoryFragmentationTest()">Iniciar Teste</button>
        <button onclick="stopMemoryFragmentationTest()">Parar Teste</button>
        <div id="fragMemStatus" class="result">Status: Inativo</div>

        ---

        <h2>2. Teste de Carregamento de Recursos Excessivos/Inválidos</h2>
        <p>Tenta carregar um número absurdo de elementos HTML (imagens, divs) ou recursos inválidos. Observar consumo de CPU/Memória.</p>
        <input type="number" id="numElements" value="10000" min="1000" max="100000" step="1000" style="width: 20%;">
        <button onclick="loadExcessiveElements()">Carregar Elementos HTML</button>
        <button onclick="loadInvalidImage()">Carregar Imagem Inválida</button>
        <div id="excessiveLoadStatus" class="result">Status: Aguardando...</div>
        <div id="elementContainer"></div>

        ---

        <h2>3. Teste de Web Workers (Processamento em Segundo Plano)</h2>
        <p>Inicia um Web Worker para fazer cálculos pesados. Verifica se o navegador continua responsivo e se o worker é isolado.</p>
        <button onclick="startWorkerStress()">Iniciar Worker Stress</button>
        <button onclick="stopWorkerStress()">Parar Worker Stress</button>
        <div id="workerStatus" class="result">Status: Inativo</div>

        ---

        <h2>4. Teste de Exaustão de Conexões de Rede (WebSockets)</h2>
        <p>Tenta abrir e manter um grande número de conexões WebSocket. Pode esgotar limites de conexão do sistema.</p>
        <input type="number" id="numWebsockets" value="500" min="10" max="2000" step="10">
        <button onclick="startWebSocketExhaustion()">Iniciar Exaustão WS</button>
        <button onclick="closeAllWebSockets()">Fechar Todos WS</button>
        <div id="wsExhaustStatus" class="result">Status: Inativo</div>

        ---

        <h2>5. Teste de Iframe Sandbox Bypass</h2>
        <p>Carrega iframes com diferentes atributos de sandbox. Verifique se o conteúdo do iframe pode quebrar o isolamento.</p>
        <button onclick="testIframeSandbox()">Testar Iframes</button>
        <div id="iframeSandboxStatus" class="result">Status: Aguardando...</div>

        ---

        <h2>9. Teste de Estresse Gráfico (Canvas Animado) - *Mantido para referência/comparação*</h2>
        <p>Desenha animações complexas em um canvas para estressar o motor de renderização do navegador.</p>
        <button onclick="startGraphicsStress()">Iniciar Estresse Gráfico</button>
        <button onclick="stopGraphicsStress()">Parar Estresse Gráfico</button>
        <canvas id="graphicsCanvas" width="400" height="200" style="border: 1px solid black; background-color: #eee;"></canvas>
        <div id="graphicsStatus" class="result">Status: Inativo</div>

        ---

        <h2>Resultados do Console (Log):</h2>
        <pre id="consoleLog"></pre>
    </div>

    <script>
        const consoleLogElement = document.getElementById('consoleLog');
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            let color = 'black';
            if (type === 'error') color = 'red';
            if (type === 'success') color = 'green';
            consoleLogElement.innerHTML += `<span style="color: ${color};">[${timestamp}] ${message}</span>\n`;
            consoleLogElement.scrollTop = consoleLogElement.scrollHeight;
        }

        // --- Teste 1: Teste de Fragmentação de Memória e Objetos Pesados ---
        let fragMemInterval;
        let runningFragMemTest = false;
        let generatedObjects = [];

        function startMemoryFragmentationTest() {
            if (runningFragMemTest) return;
            runningFragMemTest = true;
            document.getElementById('fragMemStatus').textContent = 'Status: Gerando e destruindo objetos... Observar lentidão.';
            log('Teste Frag. Memória: Iniciando...', 'info');

            let counter = 0;
            fragMemInterval = setInterval(() => {
                // Cria um objeto "pesado"
                const bigObject = {
                    data: new Uint32Array(1024 * 1024 / 4), // 1MB de dados
                    metadata: {
                        id: counter++,
                        timestamp: Date.now(),
                        randomString: Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15)
                    }
                };
                generatedObjects.push(bigObject);

                // A cada 100 objetos, remove 50 para forçar o coletor de lixo a trabalhar
                if (generatedObjects.length > 200 && generatedObjects.length % 100 === 0) {
                    generatedObjects.splice(0, 50); // Remove os primeiros 50
                    log(`Teste Frag. Memória: Gerados ${counter} objetos, ${generatedObjects.length} ativos. Forçando GC...`, 'info');
                }

                if (generatedObjects.length > 500) { // Limita o número total de objetos ativos
                    generatedObjects.splice(0, 100);
                }

            }, 50); // Cria um objeto a cada 50ms
        }

        function stopMemoryFragmentationTest() {
            if (!runningFragMemTest) return;
            runningFragMemTest = false;
            clearInterval(fragMemInterval);
            generatedObjects = []; // Limpa todos os objetos
            document.getElementById('fragMemStatus').textContent = 'Status: Parado. Memória liberada.';
            log('Teste Frag. Memória: Parado. Objetos liberados.', 'success');
        }

        // --- Teste 2: Teste de Carregamento de Recursos Excessivos/Inválidos ---
        function loadExcessiveElements() {
            const numElements = parseInt(document.getElementById('numElements').value);
            const elementContainer = document.getElementById('elementContainer');
            const excessiveLoadStatus = document.getElementById('excessiveLoadStatus');
            elementContainer.innerHTML = ''; // Limpa elementos anteriores

            log(`Teste Excesso de Elementos: Carregando ${numElements} elementos HTML...`, 'info');
            excessiveLoadStatus.textContent = `Status: Carregando ${numElements} elementos... (Pode travar)`;

            // Usar requestAnimationFrame para evitar congelar o navegador imediatamente
            let count = 0;
            const startTime = Date.now();

            function addElementChunk() {
                const fragment = document.createDocumentFragment();
                for (let i = 0; i < 1000 && count < numElements; i++) { // Adiciona em chunks de 1000
                    const div = document.createElement('div');
                    div.style.width = '1px';
                    div.style.height = '1px';
                    div.style.backgroundColor = 'blue';
                    div.style.display = 'inline-block';
                    fragment.appendChild(div);
                    count++;
                }
                elementContainer.appendChild(fragment);

                if (count < numElements) {
                    requestAnimationFrame(addElementChunk);
                } else {
                    const endTime = Date.now();
                    log(`Teste Excesso de Elementos: Carregados ${numElements} elementos em ${endTime - startTime}ms.`, 'success');
                    excessiveLoadStatus.textContent = `Status: Carregados ${numElements} elementos. Observar consumo de recursos.`;
                }
            }
            requestAnimationFrame(addElementChunk);
        }

        function loadInvalidImage() {
            const excessiveLoadStatus = document.getElementById('excessiveLoadStatus');
            const elementContainer = document.getElementById('elementContainer');
            elementContainer.innerHTML = ''; // Limpa elementos anteriores

            log('Teste Imagem Inválida: Tentando carregar imagem com dados corrompidos...', 'info');
            excessiveLoadStatus.textContent = 'Status: Tentando carregar imagem inválida...';

            const img = new Image();
            img.onload = () => {
                log('Teste Imagem Inválida: ATENÇÃO! Imagem inválida carregada com sucesso! Isso pode indicar falha no parser de imagem.', 'error');
                excessiveLoadStatus.textContent = 'Status: Imagem inválida carregada (Problema!)';
                elementContainer.appendChild(img);
            };
            img.onerror = () => {
                log('Teste Imagem Inválida: Falha ao carregar imagem inválida. (Comportamento esperado)', 'success');
                excessiveLoadStatus.textContent = 'Status: Falha ao carregar imagem inválida (OK)';
            };
            // Base64 de uma imagem JPEG intencionalmente corrompida (dados incompletos ou inválidos)
            img.src = 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/2wBD'; // Cabeçalho JPEG incompleto
        }

        // --- Teste 3: Teste de Web Workers (Processamento em Segundo Plano) ---
        let worker;
        let workerRunning = false;
        function startWorkerStress() {
            if (workerRunning) return;
            workerRunning = true;
            document.getElementById('workerStatus').textContent = 'Status: Iniciando Web Worker...';
            log('Teste Web Worker: Iniciando...', 'info');

            const workerScriptContent = `
                onmessage = function(e) {
                    if (e.data === 'start') {
                        let result = 0;
                        for (let i = 0; i < 5000000000; i++) { // Loop pesado
                            result += Math.sqrt(i);
                        }
                        postMessage('done');
                    } else if (e.data === 'stop') {
                        // Não há um jeito limpo de parar um loop pesado de dentro do worker sem WebAssembly
                        // Apenas sinaliza que o worker deveria parar
                    }
                };
            `;
            const blob = new Blob([workerScriptContent], { type: 'application/javascript' });
            worker = new Worker(URL.createObjectURL(blob));

            worker.onmessage = (e) => {
                if (e.data === 'done') {
                    document.getElementById('workerStatus').textContent = 'Status: Web Worker terminou o processamento pesado.';
                    log('Teste Web Worker: Processamento pesado concluído pelo worker.', 'success');
                    workerRunning = false;
                    worker.terminate();
                }
            };
            worker.onerror = (e) => {
                document.getElementById('workerStatus').textContent = `Status: Erro no Web Worker: ${e.message}`;
                log(`Teste Web Worker: Erro: ${e.message}. (Observar se o navegador travou)`, 'error');
                workerRunning = false;
            };

            worker.postMessage('start');
            document.getElementById('workerStatus').textContent = 'Status: Web Worker rodando cálculo pesado. Navegador deve permanecer responsivo.';
        }

        function stopWorkerStress() {
            if (!workerRunning) return;
            log('Teste Web Worker: Solicitando parada (pode não parar imediatamente se o cálculo for muito pesado)...', 'info');
            if (worker) {
                worker.terminate(); // Tenta terminar o worker
                workerRunning = false;
                document.getElementById('workerStatus').textContent = 'Status: Web Worker parado (terminado).';
                log('Teste Web Worker: Worker terminado.', 'success');
            }
        }

        // --- Teste 4: Teste de Exaustão de Conexões de Rede (WebSockets) ---
        let activeWebSockets = [];
        let wsExhaustionRunning = false;
        function startWebSocketExhaustion() {
            if (wsExhaustionRunning) return;
            wsExhaustionRunning = true;
            const numWebsockets = parseInt(document.getElementById('numWebsockets').value);
            const wsExhaustStatus = document.getElementById('wsExhaustStatus');
            wsExhaustStatus.textContent = `Status: Abrindo ${numWebsockets} WebSockets...`;
            log(`Teste Exaustão WS: Tentando abrir ${numWebsockets} conexões...`, 'info');

            activeWebSockets = [];
            let openedCount = 0;
            let errorCount = 0;

            // Use um servidor WebSocket real para isso, como 'ws://echo.websocket.events' ou um local de teste
            // Para um teste simples, podemos usar um endereço que falhe, mas o objetivo é ver o comportamento ao tentar abrir MUITAS.
            const targetWsUrl = 'ws://echo.websocket.events'; // Um servidor de teste público
            // const targetWsUrl = 'ws://127.0.0.1:9999'; // Tentar uma porta local não existente para ver o erro

            for (let i = 0; i < numWebsockets; i++) {
                try {
                    const ws = new WebSocket(targetWsUrl);
                    activeWebSockets.push(ws);

                    ws.onopen = () => {
                        openedCount++;
                        wsExhaustStatus.textContent = `Status: Conexões abertas: ${openedCount}/${numWebsockets}. Erros: ${errorCount}.`;
                        // log(`WS ${i} aberto.`, 'info');
                    };
                    ws.onerror = (e) => {
                        errorCount++;
                        // log(`WS ${i} erro.`, 'error');
                        wsExhaustStatus.textContent = `Status: Conexões abertas: ${openedCount}/${numWebsockets}. Erros: ${errorCount}.`;
                    };
                    ws.onclose = () => {
                        // log(`WS ${i} fechado.`, 'info');
                        wsExhaustStatus.textContent = `Status: Conexões abertas: ${openedCount}/${numWebsockets}. Erros: ${errorCount}.`;
                    };
                } catch (e) {
                    errorCount++;
                    log(`Teste Exaustão WS: Erro ao iniciar WS ${i}: ${e.message}`, 'error');
                }
            }
            log(`Teste Exaustão WS: Tentativa de abrir ${numWebsockets} WebSockets concluída. Observe o console para erros.`, 'success');
            wsExhaustStatus.textContent = `Status: Tentativa concluída. Conexões abertas: ${openedCount}. Erros: ${errorCount}.`;
        }

        function closeAllWebSockets() {
            if (!wsExhaustionRunning) return;
            log('Teste Exaustão WS: Fechando todas as conexões WebSocket...', 'info');
            activeWebSockets.forEach(ws => {
                if (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING) {
                    ws.close();
                }
            });
            activeWebSockets = [];
            wsExhaustionRunning = false;
            document.getElementById('wsExhaustStatus').textContent = 'Status: Todas as conexões WebSocket fechadas.';
            log('Teste Exaustão WS: Todas as conexões fechadas.', 'success');
        }

        // --- Teste 5: Teste de Iframe Sandbox Bypass ---
        function testIframeSandbox() {
            const iframeSandboxStatus = document.getElementById('iframeSandboxStatus');
            iframeSandboxStatus.innerHTML = 'Status: Iniciando testes de iframe sandbox...<br>';
            log('Teste Iframe Sandbox: Iniciando...', 'info');

            const testConfigs = [
                { id: 'iframe1', title: 'Nenhum Sandbox (Perigoso)', sandbox: '' },
                { id: 'iframe2', title: 'Sandbox Básico (Scripts Bloqueados)', sandbox: 'allow-scripts' },
                { id: 'iframe3', title: 'Sandbox com Restrição Total', sandbox: 'allow-same-origin' }, // Tentativa de simular uma restrição
                { id: 'iframe4', title: 'Sandbox Sem Top-Navigation', sandbox: 'allow-scripts allow-forms allow-same-origin' }
            ];

            testConfigs.forEach(config => {
                const iframe = document.createElement('iframe');
                iframe.id = config.id;
                iframe.width = '300';
                iframe.height = '100';
                iframe.style.border = '1px solid black';
                iframe.sandbox = config.sandbox;
                iframe.srcdoc = `
                    <!DOCTYPE html>
                    <html>
                    <head><title>${config.title}</title></head>
                    <body>
                        <h3>${config.title}</h3>
                        <p id="message">Testando...</p>
                        <script>
                            try {
                                // Tentar acessar o pai (parent)
                                if (window.parent !== window) {
                                    document.getElementById('message').textContent += ' | Acesso ao parent OK.';
                                } else {
                                    document.getElementById('message').textContent += ' | Acesso ao parent BLOQUEADO (Esperado com sandbox).';
                                }
                                // Tentar executar alert (deve ser bloqueado sem allow-scripts)
                                setTimeout(() => { alert('${config.title} - Script Executado!'); }, 500);
                                document.getElementById('message').textContent += ' | Alerta agendado.';
                            } catch (e) {
                                document.getElementById('message').textContent += ' | Erro no script: ' + e.message;
                            }
                            // Tentar navegação top-level
                            // setTimeout(() => { window.top.location.href = 'https://google.com'; }, 1000);
                        </script>
                    </body>
                    </html>
                `;

                iframe.onload = () => {
                    log(`Iframe ${config.title}: Carregado.`, 'info');
                    try {
                        // Tentar acessar o conteúdo do iframe a partir do pai
                        const iframeDoc = iframe.contentWindow.document;
                        const messageElement = iframeDoc.getElementById('message');
                        log(`Iframe ${config.title}: Mensagem interna: "${messageElement ? messageElement.textContent : 'Não acessível'}"`, 'info');
                    } catch (e) {
                        log(`Iframe ${config.title}: Bloqueado pelo Same-Origin Policy (esperado para sandbox sem allow-same-origin). Erro: ${e.message}`, 'success');
                    }
                };
                iframe.onerror = () => {
                    log(`Iframe ${config.title}: Erro ao carregar.`, 'error');
                };

                document.getElementById('iframeSandboxStatus').appendChild(iframe);
                document.getElementById('iframeSandboxStatus').innerHTML += `<br>`;
            });
            log('Teste Iframe Sandbox: Testes iniciados. Observe os comportamentos dos iframes.', 'success');
        }

        // --- Teste 9: Teste de Estresse Gráfico (Canvas Animado) ---
        // Este teste foi mantido do arquivo anterior.
        let animationFrameId;
        let isGraphicsStressRunning = false;
        function startGraphicsStress() {
            if (isGraphicsStressRunning) return;
            isGraphicsStressRunning = true;

            const canvas = document.getElementById('graphicsCanvas');
            const ctx = canvas.getContext('2d');
            const graphicsStatus = document.getElementById('graphicsStatus');
            log('Teste Gráfico: Iniciando estresse gráfico...', 'info');
            graphicsStatus.textContent = 'Status: Rodando... (Observar desempenho e estabilidade)';

            let angle = 0;
            const draw = () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                for (let i = 0; i < 50; i++) {
                    const x = canvas.width / 2 + Math.cos(angle + i * 0.1) * (100 + i * 0.5);
                    const y = canvas.height / 2 + Math.sin(angle + i * 0.1) * (50 + i * 0.2);
                    const radius = 5 + Math.sin(angle * 0.5 + i * 0.2) * 3;

                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fillStyle = `hsl(${angle * 10 % 360}, 70%, 50%)`;
                    ctx.fill();
                }

                angle += 0.05;
                animationFrameId = requestAnimationFrame(draw);
            };

            animationFrameId = requestAnimationFrame(draw);
        }

        function stopGraphicsStress() {
            if (!isGraphicsStressRunning) return;
            isGraphicsStressRunning = false;
            cancelAnimationFrame(animationFrameId);
            document.getElementById('graphicsStatus').textContent = 'Status: Inativo';
            log('Teste Gráfico: Estresse gráfico parado.', 'info');
        }
    </script>
</body>
</html>
